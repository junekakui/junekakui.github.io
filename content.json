{"meta":{"title":"Junekakui","subtitle":"黑眼圈肥猫的进阶路","description":"Just do it!","author":"Junekakui L","url":"http://junekakui.github.io","root":"/"},"pages":[],"posts":[{"title":"LeetCode—1twoSum","slug":"LeetCode—1twoSum","date":"2019-11-19T12:28:27.654Z","updated":"2019-11-21T11:38:14.797Z","comments":true,"path":"2019/11/19/LeetCode—1twoSum/","link":"","permalink":"http://junekakui.github.io/2019/11/19/LeetCode%E2%80%941twoSum/","excerpt":"LeetCode刷题总结 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。","text":"LeetCode刷题总结 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 题目概述简单 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 第一次思路暴力循环，依次查找 Code123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result; for(int i = 0;i &lt; nums.size();++i) &#123; for(int j = i + 1;j &lt; nums.size();++j) &#123; if(nums[i] + nums[j] == target) &#123; result.push_back(i); result.push_back(j); &#125; &#125; &#125; return result; &#125;&#125;; 方法总结 暴力循环法 如上 两遍哈希表 将数组中的元素和元素的索引依次放到哈希表中 第一次循环：数组中的元素和元素的索引依次放到哈希表中 第二次循环：查找目标元素1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int,int&gt; a;//建立hash表存放数组元素 vector&lt;int&gt; b(2,-1);//存放结果 for(int i=0;i&lt;nums.size();i++) a.insert(map&lt;int,int&gt;::value_type(nums[i],i)); for(int i=0;i&lt;nums.size();i++) &#123; if(a.count(target-nums[i])&gt;0&amp;&amp;(a[target-nums[i]]!=i)) //判断是否找到目标元素且目标元素不能是本身 &#123; b[0]=i; b[1]=a[target-nums[i]]; break; &#125; &#125; return b; &#125;;&#125;; 一遍哈希表 将数组中的元素和元素的索引依次放到哈希表中 在投放数据的同时，在已有的元素中查找目标元素 如果查找到目标元素，则直接返回向量；如果没查找到，则将数组中的元素放到哈希表中，继续下一次循环123456789101112class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; dict; for (int i = 0; i &lt; nums.size(); i++) if (dict.count(target - nums[i])) return &#123;dict[target - nums[i]], i&#125;; else dict[nums[i]] = i; return &#123;0, 0&#125;; &#125;&#125;;","categories":[],"tags":[]},{"title":"LeetCode—13romanToInt","slug":"LeetCode—13romanToInt","date":"2019-11-19T12:15:57.096Z","updated":"2019-11-21T11:39:02.856Z","comments":true,"path":"2019/11/19/LeetCode—13romanToInt/","link":"","permalink":"http://junekakui.github.io/2019/11/19/LeetCode%E2%80%9413romanToInt/","excerpt":"LeetCode刷题总结 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。","text":"LeetCode刷题总结 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 题目概述12345678910111213141516171819202122232425262728293031323334353637383940414243简单罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例 1:输入: &quot;III&quot;输出: 3示例 2:输入: &quot;IV&quot;输出: 4示例 3:输入: &quot;IX&quot;输出: 9示例 4:输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 第一次思路 用哈希表存储对应关系 定义一个标量存储当前元素的上一个元素代表的数值，将此变量与当前元素所代表的数字比较：如果上一个元素小，则当前元素的数值减去上一个元素的数值；如果上一个元素大，则当前元素与上一个元素相加。 Code123456789101112131415161718192021222324252627class Solution &#123;public: int romanToInt(string s) &#123; map&lt;string,int&gt; a; int len=s.size(),num=0,f=-1; string l; a[&quot;I&quot;]=1; a[&quot;V&quot;]=5; a[&quot;X&quot;]=10; a[&quot;L&quot;]=50; a[&quot;C&quot;]=100; a[&quot;D&quot;]=500; a[&quot;M&quot;]=1000; for(int i=len;i&gt;-1;i--)&#123; l=s[i]; if(f==-1||f&lt;=a[l]) &#123; num +=a[l]; f=a[l]; &#125; else &#123; num -=a[l]; f=a[l]; &#125; &#125; return num; &#125;&#125;; 分析 提交结果： 执行结果：通过显示详情执行用时 :40 ms, 在所有 cpp 提交中击败了28.75%的用户内存消耗 :12.7 MB, 在所有 cpp 提交中击败了72.75%的用户 哈希表的建立可简化为：1map&lt;string, int&gt; m = &#123;&#123;&quot;I&quot;, 1&#125;, &#123;&quot;IV&quot;, 3&#125;, &#123;&quot;IX&quot;, 8&#125;, &#123;&quot;V&quot;, 5&#125;, &#123;&quot;X&quot;, 10&#125;, &#123;&quot;XL&quot;, 30&#125;, &#123;&quot;XC&quot;, 80&#125;, &#123;&quot;L&quot;, 50&#125;, &#123;&quot;C&quot;, 100&#125;, &#123;&quot;CD&quot;, 300&#125;, &#123;&quot;CM&quot;, 800&#125;, &#123;&quot;D&quot;, 500&#125;, &#123;&quot;M&quot;, 1000&#125;&#125;; 方法总结 用哈希表存储单个字符与数值之间的对应关系对应关系 如上 将”IV”、”IX”等视为整体，不需要减只用加 构造罗马数字时，相邻的两个字符最多只有一个字母表示减，比如：会出现”IV”，但不会出现”IIV” c++实现 用two和one表示字符是两个构成还是三个构成 “IV”表示3，”IX”,表示8，以此类推，因为从前向后扫描字符串，只加不减，在扫描”IV”时，首先判断”I”加一，然后构造”IV”，再加3，得到正确结果4 12345678910111213class Solution &#123;public: int romanToInt(string s) &#123; unordered_map&lt;string, int&gt; m = &#123;&#123;&quot;I&quot;, 1&#125;, &#123;&quot;IV&quot;, 3&#125;, &#123;&quot;IX&quot;, 8&#125;, &#123;&quot;V&quot;, 5&#125;, &#123;&quot;X&quot;, 10&#125;, &#123;&quot;XL&quot;, 30&#125;, &#123;&quot;XC&quot;, 80&#125;, &#123;&quot;L&quot;, 50&#125;, &#123;&quot;C&quot;, 100&#125;, &#123;&quot;CD&quot;, 300&#125;, &#123;&quot;CM&quot;, 800&#125;, &#123;&quot;D&quot;, 500&#125;, &#123;&quot;M&quot;, 1000&#125;&#125;; int r = m[s.substr(0, 1)]; for(int i=1; i&lt;s.size(); ++i)&#123; string two = s.substr(i-1, 2); string one = s.substr(i, 1); r += m[two] ? m[two] : m[one]; &#125; return r; &#125;&#125;; s.substr(0, 1):获得字符串s中从0位开始，长度为1的字符串 python实现 1234class Solution: def romanToInt(self, s: str) -&gt; int: d = &#123;&apos;I&apos;:1, &apos;IV&apos;:3, &apos;V&apos;:5, &apos;IX&apos;:8, &apos;X&apos;:10, &apos;XL&apos;:30, &apos;L&apos;:50, &apos;XC&apos;:80, &apos;C&apos;:100, &apos;CD&apos;:300, &apos;D&apos;:500, &apos;CM&apos;:800, &apos;M&apos;:1000&#125; return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s)) dict.get(key, default)：通过 key 从 d 中找出对应的值，如果 key 不存在则返回默认值 default s[max(i-1, 0):i+1]：为了防止出现当i=0时出现溢出 d.get(s[max(i-1, 0):i+1], d[n]：每次搜索两个字符，如果两个字符没有搜索到，则结果为default，即当前值d[n]","categories":[],"tags":[]},{"title":"LeetCode—9isPalindrome","slug":"LeetCode—9isPalindrome","date":"2019-11-17T09:26:27.697Z","updated":"2019-11-21T11:39:11.408Z","comments":true,"path":"2019/11/17/LeetCode—9isPalindrome/","link":"","permalink":"http://junekakui.github.io/2019/11/17/LeetCode%E2%80%949isPalindrome/","excerpt":"LeetCode刷题总结 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。","text":"LeetCode刷题总结 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 题目概述123456789101112131415161718192021简单判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。示例 1:输入: 121输出: true示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。进阶:你能不将整数转为字符串来解决这个问题吗？ 第一次思路 将整数翻转，判断两个数是否相等 负数一定不是回文数 Code12345678910111213class Solution &#123;public: bool isPalindrome(int x) &#123; long y=0; int k=x; while (x != 0) &#123; y = (x % 10)+y*10; x = x / 10; &#125; if(y==k&amp;&amp;k&gt;=0)return true; else return false; &#125;&#125;; 方法总结 翻转一半数字 所有负数返回false 将x除以10得到第一位余数，第二位余数，将第一位余数乘10加上第二位余数，得到后两位的翻转数，依次进行 判断数字翻转了一半的方法：原始数字不断除以10，当原始数字小于翻转后的数字时，则已经翻转了一半了 考虑特殊情况0：如果x的最后一位是0，为了满足回文数，则第一位也是零，只有0 考虑特殊情况x是奇位数：当x的长度是奇数时，通过 revertedNumber/10 去除处于中位的数字。中位数字不影响回文数。满足这一要求123456789101112131415class Solution &#123;public: bool isPalindrome(int x) &#123;if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; return false; &#125; int revertedNumber = 0; while(x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; return x == revertedNumber || x == revertedNumber/10; &#125;&#125;; 将x翻转再与原来作比较12345678910111213class Solution &#123;public: bool isPalindrome(int x) &#123; long y=0; int k=x; while (x != 0) &#123; y = (x % 10)+y*10; x = x / 10; &#125; if(y==k&amp;&amp;k&gt;=0)return true; else return false; &#125;&#125;; 转化为字符串比较 将整数转为字符串 ，然后将字符串分割为数组，只循环数组的一半长度判断对应元素是否相等 123456789101112131415161718192021222324class Solution&#123;public: bool isPalindrome(int x) &#123; bool result; if (x &lt; 0) &#123; return false; &#125; stringstream ss; ss &lt;&lt; x; string str, reversedStr; ss &gt;&gt; str; int strSize = int(str.size()); for (int index = strSize - 1; index &gt;= 0; index--) &#123; reversedStr.push_back(str[index]); &#125; result = str == reversedStr; return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"LeetCode—7reserve_int","slug":"LeetCode—7reserve_int","date":"2019-11-17T08:37:22.430Z","updated":"2019-11-21T11:39:27.688Z","comments":true,"path":"2019/11/17/LeetCode—7reserve_int/","link":"","permalink":"http://junekakui.github.io/2019/11/17/LeetCode%E2%80%947reserve_int/","excerpt":"LeetCode刷题总结 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。","text":"LeetCode刷题总结 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 题目概述12345678910111213141516171819简单给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例 1:输入: 123输出: 321 示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 第一次思路 判断整数的正负，用k标记，并且将负数转化为正数 为了完成溢出返回0，用long数据类型判断整数是否在范围内，2^31-1=2147483647,-2^31=-2147483648 Code123456789101112131415161718class Solution &#123;public: int reverse(int x) &#123; long y=0, k=1,z=x; if (x &lt; 0) &#123; k = -1; z *= -1; &#125; while (z &gt; 0) &#123; if(y*10&gt;2147483647)&#123; return 0; &#125; y = (z % 10)+y*10; z = z / 10; &#125; return y*k; &#125;&#125;; 方法总结 简洁的写法1234567int reverse(int x)&#123; int max = 0x7fffffff, min = 0x80000000;//int的最大值最小值 long rs = 0;//用long类型判断溢出 for(;x;rs = rs*10+x%10,x/=10);//逆序，正负通吃，不用单独考虑负值 return rs&gt;max||rs&lt;min?0:rs;//超了最大值低于最小值就返回0&#125; 官方解答 x是正数时， 如果溢出，则有rev &gt; INT_MAX/10 所以： 当rev &gt; INT_MAX/10时，rev⋅10+pop一定溢出 当rev == INT_MAX/10时，由于2^31-1=2147483647,-2^31=-2147483648，当pop&gt;7时，一定溢出 负数同理 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; int rev = 0; while (x != 0) &#123; int pop = x % 10; x /= 10; if (rev &gt; INT_MAX/10 || (rev == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0; if (rev &lt; INT_MIN/10 || (rev == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0; rev = rev * 10 + pop; &#125; return rev; &#125;&#125;; long转化为int判断是否溢出 一个负数除以10得到的除数是负数，所以不需要另外判断x的正负 将y强制转化为int类型，如果溢出，则转化后的数和原来的不相等，可以用来判断是否溢出 12345678910111213141516class Solution &#123;public: int reverse(int x) &#123; long y=0; while (x != 0) &#123; y = (x % 10)+y*10; x = x / 10; &#125; if((int)y!=y)&#123; return 0; &#125;else&#123; return (int)y; &#125; &#125;&#125;;","categories":[],"tags":[]},{"title":"mysql8.0忘记密码或出现不可访问","slug":"mysql8.0忘记密码或出现不可访问","date":"2019-11-14T13:32:12.986Z","updated":"2019-11-14T14:07:03.867Z","comments":true,"path":"2019/11/14/mysql8.0忘记密码或出现不可访问/","link":"","permalink":"http://junekakui.github.io/2019/11/14/mysql8.0%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E6%88%96%E5%87%BA%E7%8E%B0%E4%B8%8D%E5%8F%AF%E8%AE%BF%E9%97%AE/","excerpt":"1、找到mysql安装路径2、以管理员身份打开命令行，停止服务……","text":"1、找到mysql安装路径2、以管理员身份打开命令行，停止服务…… 1、找到mysql安装路径 （可以在环境变量中找） 2、以管理员身份打开命令行，停止服务 （win+q输入cmd右击） （net stop mysql） 3、cd 到mysql安装路径的bin目录，之前版本输入mysqld –skip-grant-tables，8.0输入mysqld –console –skip-grant-tables –shared-memory 4、打开另一个管理员命令行，cd 到mysql安装路径的bin目录，输入mysql，输入use mysql 5、flush privileges； 6、使用alter user’root’@’localhost’ IDENTIFIED BY ‘Li！123456’; 修改密码 （8.0以后版本密码必须包含大小写字母特殊字符和数字） flush privileges； 7、\\q退出 8、重新以管理员打开命令行，net start mysql 9、登陆 mysql -u root -p 。。。。。。。。。。。。。想哭。。。。。。。。。。。。。。","categories":[],"tags":[]},{"title":"bs处理后的源代码用正则表达式需要转化格式","slug":"bs处理后的源代码用正则表达式需要转化格式","date":"2019-11-14T13:29:49.282Z","updated":"2019-11-14T14:06:33.056Z","comments":true,"path":"2019/11/14/bs处理后的源代码用正则表达式需要转化格式/","link":"","permalink":"http://junekakui.github.io/2019/11/14/bs%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%9C%80%E8%A6%81%E8%BD%AC%E5%8C%96%E6%A0%BC%E5%BC%8F/","excerpt":"用beautifulsoup抓取下来的内容自动保存为list格式，想要继续用正则表达式提取，需要转化成字符串的形式。","text":"用beautifulsoup抓取下来的内容自动保存为list格式，想要继续用正则表达式提取，需要转化成字符串的形式。 抓取主页面热点新闻，写入tengxun_news.txt 1234567891011def get_main_page(): resp_main_page = get_html(main_page_utl) soup_1 = BeautifulSoup(resp_main_page.text,&quot;lxml&quot;) item_1s = soup_1.select(&quot;.linkto&quot;) print(item_1s) print(&quot;-------------------------------------------------------------------&quot;) html = item_1s pattern = re.compile(&apos;&lt;a class=&quot;linkto&quot; href=(.*?) target=&quot;_blank&quot;&gt;(.*?)&lt;/a&gt;,&apos;, re.S) items = re.findall(pattern, html) print(items) 用beautifulsoup抓取下来的内容自动保存为list格式，想要继续用正则表达式提取，需要转化成字符串的形式。 抓取主页面热点新闻，写入tengxun_news.txt 1234567891011def get_main_page():resp_main_page = get_html(main_page_utl)soup_1 = BeautifulSoup(resp_main_page.text,&quot;lxml&quot;)item_1s = soup_1.select(&quot;.linkto&quot;)print(item_1s)print(&quot;-------------------------------------------------------------------&quot;)html = str(item_1s)pattern = re.compile(&apos;&lt;a class=&quot;linkto&quot; href=(.*?) target=&quot;_blank&quot;&gt;(.*?)&lt;/a&gt;,&apos;, re.S)items = re.findall(pattern, html)print(items) 参考：https://blog.csdn.net/weixin_42105977/article/details/80390957","categories":[],"tags":[]},{"title":"C++学习—函数","slug":"C++学习—函数","date":"2019-11-14T12:05:53.291Z","updated":"2019-11-19T12:14:28.853Z","comments":true,"path":"2019/11/14/C++学习—函数/","link":"","permalink":"http://junekakui.github.io/2019/11/14/C++%E5%AD%A6%E4%B9%A0%E2%80%94%E5%87%BD%E6%95%B0/","excerpt":"函数的定义与使用内联函数带默认形参值的函数重载函数C++系统函数","text":"函数的定义与使用内联函数带默认形参值的函数重载函数C++系统函数 一、定义与使用1、函数的定义1234类型标识符 函数名（形式参数列表）&#123; 声明部分 语句&#125; 形参与实参： 定义函数时，函数名后小括号内的参数为形式参数； 在主函数中调用定义的函数时，函数名后的小括号内的参数名为实际参数。 注意：在执行一个被调用函数时，形参的值如果发生改变，并不会改变主函数中实参的值 2、引用参数1234类型名&amp; 引用名=被引用的对象； int i = 3;int&amp; refi = i; 通过被引用对象地址的直接传递实现的，对引用的更新和赋值将直接操作在该引用代表的对象上 3、函数的调用1函数名 ([实参表列]) （1）如果使用库函数，则在开头使用#include命令将有关头文件嵌入到本文件中 （2）如果调用用户自己定义的函数且被调用函数在主函数的后面， 123456789101112int main()&#123; float add(float x,float y);//对add函数进行声明 float a,b,c; c = add(a,b);&#125; float add(float x,float y)&#123;//定义add函数 float z; z=x+y; return (z);&#125; 二、内联函数内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。 有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销。 1234567891011121314151617#include &lt;iostream&gt;using namespace std;inline int abs(int);//声明内联函数 int main()&#123; int i=-10,m; m = abs(i); cout&lt;&lt;m&lt;&lt;endl; return 0;&#125; inline int abs (int a)//定义abs为内联函数&#123; if(a &gt;0) return a; else return -a;&#125; 注意： （1）内联函数只能先定义后使用，否则编译系统会将其视为普通函数 （2）不一定所有inline修饰的含糊都会被编译器认为是内联函数；没有inline修饰的函数也可能被编译器认为是内联函数 三、带默认形参值的函数12345678int Sum(int n,int i=1)&#123; &#125; 调用：Sum(1)Sum(1,4) 注意： 如果函数的定义在调用之间，则应在函数定义中给出默认值； 如果函数的定义在调用之后，则在函数调用之前应有函数声明，必须在函数生命中给出默认值，在函数定义时可以不给出默认值 四、重载函数函数名相同，但形式参数（个数、类型）不同 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;void Max(int a, int b)&#123; cout &lt;&lt; &quot;Max 1&quot; &lt;&lt; endl;&#125;void Max(double a, double b)&#123; cout &lt;&lt; &quot;Max 2&quot; &lt;&lt; endl;&#125;void Max(double a, double b, double c)&#123; cout &lt;&lt; &quot;Max 3&quot; &lt;&lt; endl;&#125;int main()&#123; Max(3, 4); //调用 int Max(int, int) Max(2.4, 6.0); //调用 double Max(doubleA double) Max(1.2, 3.4, 5); //调用 double Max(double, double, double) Max(1, 2, 3); //调用 double Max(double, double, double) return 0;&#125; 五、 C++系统函数调用系统函数时需要在文件头部用#include将函数所在的库嵌入进来","categories":[],"tags":[]},{"title":"C++学习—语句","slug":"C++学习—语句","date":"2019-11-14T11:57:53.104Z","updated":"2019-11-19T12:14:33.028Z","comments":true,"path":"2019/11/14/C++学习—语句/","link":"","permalink":"http://junekakui.github.io/2019/11/14/C++%E5%AD%A6%E4%B9%A0%E2%80%94%E8%AF%AD%E5%8F%A5/","excerpt":"数据的输入与输出选择结构循环结构自定义数据类型","text":"数据的输入与输出选择结构循环结构自定义数据类型 一、数据输入与输出 1、cout输出流（1）头文件中 ```12（2）应用 格式：cout&lt;&lt;表达式1&lt;&lt;表达式2&lt;&lt;表达式n;cout&lt;&lt;”Hello World!”&lt;&lt;”welcome!\\n”;cout&lt;&lt;”Hello World!”&lt;&lt;”Welcome!”&lt;&lt;endl; cout输出内容也可分多行书写 cout&lt;&lt;”This is” &lt;&lt;”an” &lt;&lt;”apple!” &lt;&lt;endl; 123456789（3）输出数据的格式控制引入头文件&lt;iomainip&gt;![](https://img-blog.csdnimg.cn/20191114195940183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1bmVrYWt1aQ==,size_16,color_FFFFFF,t_70)## 2、cin输入流的使用（1）程序头文件 #include 1（2）应用 float a = -1;int b = -1;cin&gt;&gt;a&gt;&gt;b;输入时，以空格隔开 12字符型数据的输入： char c1,c2;int a;float b;cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;a&gt;&gt;b;cout&lt;&lt;c1&lt;&lt;endl&lt;&lt;c2&lt;&lt;endl&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl; 输入：1234 56.78输出： 1 2 34 56.78 1 字符串数据的输入： char str1[16];cin&gt;&gt;str1;cout&lt;&lt;str1&lt;&lt;endl; 输入：Welcome to China！输出：Welcome 12# 二、选择语句## 1、if选择语句基本形式 if (表达式) 语句1else 语句2多条语句时加{} 1## 2、if选择语句嵌套选择结构 if(表达式1) if(表达式2) 语句1 else 语句2else if(表达式3) 语句3 else 语句4 1## 3、if...else if语句 if (表达式1) 语句1else if (表达式2) 语句2else if (表达式3) 语句3…else 语句n 1## 4、switch语句 switch(表达式) { case 常量表达式1：语句1 case 常量表达式2：语句2 … case 常量表达式n：语句n deflaut： 语句 n+1 } 12# 三、循环结构## 1、while语句 while(表达式) {语句} whlie(getchar()!=”\\n”) n++;getchar()!=”\\n” 从键盘输入字符 1## 2、do-whlie do {语句}while(表达式)； 1## 3、for for(表达式1；表达式2；表达式3) 语句 1## 4、break和continue break：终止循环 continue：进行下一次循环 12# 四、自定义数据类型## 1、typedef声明 typedef 已知类型名 新类型名； typedef double d1,d2; 1## 2、枚举类型enum enum 枚举类型名 {枚举常量值表列}； enum days{Mon,Tue,Wed,Thur,Fri,Sat,Sun};//定义一个枚举类型daysdays today = Mon；//定义枚举类型days的变量today 1## 3、结构体类型struct struct 结构体类型名 {成员表列}； struct date{ int month； int day； int year；} date.year = 1000;//引用结构体变量中一个成员的值 123## 4、联合体类型union联合体内的成员共享同一段内存，整个联合体占用内存单元的大小取决于最长的成员的大小 union 共用体类型名{成员表列}； union mix_t{ long l; struct { short hi; short lo; }s; char c[4];}mix;```","categories":[],"tags":[]},{"title":"C++学习—初步认识","slug":"C++学习—初步认识","date":"2019-11-14T11:10:13.105Z","updated":"2019-11-19T12:14:25.009Z","comments":true,"path":"2019/11/14/C++学习—初步认识/","link":"","permalink":"http://junekakui.github.io/2019/11/14/C++%E5%AD%A6%E4%B9%A0%E2%80%94%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/","excerpt":"字符基本数据类型和表达式","text":"字符基本数据类型和表达式 一、字符1234567 #include &lt;iostream&gt; using namespace std; void main(void) &#123; cout&lt;&lt;&quot;hello world!&quot;&lt;&lt;endl; cout&lt;&lt;&quot;welcome to world&quot;&lt;&lt;endl;&#125; 1、字符集（物理字符集）C++源程序在呗编译成目标程序时，会以字符序列的形式被编译器读取，并映射为编译时的“源字符集” （1）空格符：空格键、制表符、换行符、注释符（注释内容作为空格处理） （2）英文字符 （3）数字字符 （4）特殊字符 2、词法记号（1）关键字 （图源菜鸟教程网站） （2）标识符 使用标识符定义函数名、类名、对象名、变量名、常量名、类型名、语句标号名等 主要规则： a、以大小字母或者下划线（_）开始，区分大小写 b、其他字符可以由字母、数字、下划线构成 c、不可以使用系统中已预定义的关键词和设备名作为标识符 （3）常量 整形型量、浮点型常量、字符型常量、字符串常量、枚举常量 定义格式：const 类型说明符 常量名=常量值 a、确定常量名 b、指出常量类型 c、必须进行初始化 d、const为常量类型说明符 （4）操作符 算数运算符、关系运算符、逻辑运算符、位操作运算符、赋值运算符、三目运算符、逗号运算符、sizeof运算符、强制运算符、取地址和取内容运算符、成员选择符、运算符（）和[ ]等 （5）分隔符 程序中的标点符号 空格符、逗号、分号、冒号、圆括号、花括号等 （6）空白 空格、水平制表符（Tab）、垂直制表符、换行符、注释等的总称 （7）注释方法 单行注释 // 多行注释 /与/ 二、基本数据类型和表达式1、基本数据类型 类型 含义 可使用的修饰符 char 字符 signed、unsigned int 整数 signed、unsigned、long、short float 浮点数 double 双精度浮点数 long bool 布尔值 void 空值 wchar_1 宽字符 数据类型的修饰符主要有：signed、unsigned、long、short 2、常量两种定义方法： （1）宏常量（没有数据类型）（不能做类型安全检查和语法检查） #define PI 3.14159 （2）符号常量（有数据类型） const float PI = 3.14159 ###3、常用转义字符 ###4、变量 （1）变量声明：数据类型 变量名1，变量名2，…变量名n; （2）档需要在多个工程中的多个文件中共享一个变量时，在声明的变量前加extern关键字，表示该变量是其他程序里定义的一个外部变量。在一个没有定义该变量的文件中使用到变量时，就需要声明 （3）“引用” 相当于给变量取另外一个名字 123int a = 10;int&amp; ia = a;//ia是变量a的另一个名字ia = 20;//把20赋给ia指向的对象，也就是a 5、运算符与表达式 算数运算符 +、-、*、/、%（取余）、++、– 赋值运算符 =、+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=、^=、 逗号运算符 格式：表达式1,表达式2；a=1*2,a+3；结果为5 逻辑运算 &lt;、&lt;=、&gt;、&gt;=、==、!=、!非、&amp;&amp;与、||或、 条件运算符 （C++中唯一三元运算符）;表达式1？表达式2：表达式3； sizeof运算符 （返回一个对象或类型名的长度）;sizeof(类型名或表达式) 位运算 （对数据的二进制进行相应的运算）;&amp;（按位与）;|（按位或）;^（按位异或）;~（按位取反）;移位（舍弃和补零）：&lt;&lt;（左移运算符）、&gt;&gt;（右移运算符） 数据类型强制转化 float f = 1.2;i = (int)f;","categories":[],"tags":[]}]}